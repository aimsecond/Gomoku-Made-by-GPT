<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gomoku vs. AI (Five in a Row)</title>
  <!-- Canvas-confetti library for confetti effects -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.4.0/dist/confetti.browser.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #f7f7f7;
      margin: 0;
      padding: 20px;
      overflow-x: hidden;
    }
    h1 {
      margin-top: 20px;
    }
    /* --- Board Container & Canvas --- */
    #board {
      position: relative;
      margin: 20px auto;
      background-color: #e4d7b5;
    }
    #boardCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    /* --- Intersection Areas (clickable) --- */
    .intersection {
      position: absolute;
      z-index: 1;
      /* Transparent circle for click detection */
      background: transparent;
      border-radius: 50%;
      cursor: pointer;
    }
    /* --- Stone Style --- */
    .stone {
      position: absolute;
      border-radius: 50%;
      /* pop-in animation */
      animation: pop-in 0.3s ease-out;
      z-index: 2;
    }
    .black {
      background: black;
    }
    .white {
      background: white;
      border: 1px solid #ccc;
    }
    /* Stone pop-in animation */
    @keyframes pop-in {
      from {
        transform: scale(0);
      }
      to {
        transform: scale(1);
      }
    }
    /* Winning stones glow effect */
    .winning-stone {
      animation: glow 1s infinite alternate;
    }
    @keyframes glow {
      from {
        box-shadow: 0 0 10px 5px yellow;
      }
      to {
        box-shadow: 0 0 20px 10px orange;
      }
    }
    /* Ribbon effect styling */
    .ribbon {
      position: fixed;
      width: 10px;
      height: 40px;
      opacity: 0.8;
      z-index: 1000;
      animation: fall 2s ease-out forwards;
    }
    @keyframes fall {
      0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    /* Message and button styles */
    #message {
      margin: 20px;
      font-size: 1.2em;
    }
    #restart {
      padding: 10px 20px;
      font-size: 1em;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Gomoku vs. AI (Five in a Row)</h1>
  <div id="board">
    <canvas id="boardCanvas"></canvas>
  </div>
  <div id="message">Current Turn: Black</div>
  <button id="restart">Restart Game</button>

  <script>
    /********** CONFIGURATION **********/
    const boardSize = 15;      // Number of intersections per side
    const spacing = 40;        // Distance (in px) between intersections
    const boardMargin = 20;    // Margin from edge of canvas to first intersection
    const stoneSize = 30;      // Diameter of each stone
    const clickAreaSize = 30;  // Diameter of the invisible clickable circle

    // Calculate board pixel dimensions
    const boardPixelSize = boardMargin * 2 + spacing * (boardSize - 1);
    const AI_SEARCH_DEPTH = 2;  // Increased depth for better AI

    /********** STATE VARIABLES **********/
    // 2D board state: board[row][col] is '', 'black', or 'white'
    let board = [];
    // To keep track of stone DOM elements (keyed by "row-col")
    let stoneElements = {};
    let currentPlayer = 'black';  // Human is always Black; AI is White.
    let gameOver = false;

    /********** DOM ELEMENTS **********/
    const boardContainer = document.getElementById("board");
    const canvas = document.getElementById("boardCanvas");
    const ctx = canvas.getContext("2d");
    const messageEl = document.getElementById("message");
    const restartBtn = document.getElementById("restart");

    /********** PATTERN WEIGHTS **********/
    const PATTERN_WEIGHTS = {
      five: 1000000,
      openFour: 50000,
      closedFour: 1000,
      openThree: 800,
      closedThree: 150,
      openTwo: 50,
      potentialFour: 3000
    };

    /********** BOARD INITIALIZATION **********/
    function initBoard() {
      // Reset game state
      board = [];
      for (let i = 0; i < boardSize; i++) {
        board[i] = [];
        for (let j = 0; j < boardSize; j++) {
          board[i][j] = "";
        }
      }
      currentPlayer = "black";
      gameOver = false;
      messageEl.textContent = "Current Turn: Black";
      stoneElements = {};
      boardContainer.innerHTML = ""; // remove all child nodes
      // Re-add the canvas
      boardContainer.appendChild(canvas);
      // Set board and canvas sizes
      boardContainer.style.width = boardPixelSize + "px";
      boardContainer.style.height = boardPixelSize + "px";
      canvas.width = boardPixelSize;
      canvas.height = boardPixelSize;

      // Draw the board lines on the canvas
      drawBoardLines();
      // Create clickable intersections
      createIntersections();
    }

    /********** DRAW BOARD LINES **********/
    function drawBoardLines() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 1;
      // Draw horizontal lines
      for (let i = 0; i < boardSize; i++) {
        const y = boardMargin + i * spacing;
        ctx.beginPath();
        ctx.moveTo(boardMargin, y);
        ctx.lineTo(boardPixelSize - boardMargin, y);
        ctx.stroke();
      }
      // Draw vertical lines
      for (let j = 0; j < boardSize; j++) {
        const x = boardMargin + j * spacing;
        ctx.beginPath();
        ctx.moveTo(x, boardMargin);
        ctx.lineTo(x, boardPixelSize - boardMargin);
        ctx.stroke();
      }
    }

    /********** CREATE INTERSECTIONS **********/
    function createIntersections() {
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const inter = document.createElement("div");
          inter.classList.add("intersection");
          // Position the intersection: center at the grid point
          const x = boardMargin + col * spacing;
          const y = boardMargin + row * spacing;
          inter.style.width = clickAreaSize + "px";
          inter.style.height = clickAreaSize + "px";
          inter.style.left = (x - clickAreaSize / 2) + "px";
          inter.style.top = (y - clickAreaSize / 2) + "px";
          inter.dataset.row = row;
          inter.dataset.col = col;
          inter.addEventListener("click", handleIntersectionClick);
          boardContainer.appendChild(inter);
        }
      }
    }

    /********** HANDLE HUMAN MOVE **********/
    function handleIntersectionClick(e) {
      if (gameOver || currentPlayer !== "black") return;
      const row = parseInt(e.currentTarget.dataset.row, 10);
      const col = parseInt(e.currentTarget.dataset.col, 10);
      if (board[row][col] !== "") return; // Already occupied
      board[row][col] = "black";
      placeStone(row, col, "black");
      const winPositions = checkWin(row, col, "black");
      if (winPositions) {
        messageEl.textContent = "Black wins!";
        gameOver = true;
        highlightWinningStones(winPositions);
        triggerCelebrationEffect();
        return;
      }
      if (isBoardFull()) {
        messageEl.textContent = "Draw!";
        gameOver = true;
        return;
      }
      // Switch to AI turn after a short delay
      currentPlayer = "white";
      messageEl.textContent = "AI is thinking...";
      setTimeout(aiMakeMove, 500);
    }

    /********** PLACE STONE (UI) **********/
    function placeStone(row, col, player) {
      const stone = document.createElement("div");
      stone.classList.add("stone", player);
      stone.style.width = stoneSize + "px";
      stone.style.height = stoneSize + "px";
      const x = boardMargin + col * spacing;
      const y = boardMargin + row * spacing;
      stone.style.left = (x - stoneSize / 2) + "px";
      stone.style.top = (y - stoneSize / 2) + "px";
      boardContainer.appendChild(stone);
      stoneElements[`${row}-${col}`] = stone;
    }

    /********** WIN DETECTION (for recent move) **********/
    // (Reusing the earlier method that checks from the last placed stone)
        // Check if a given player has a five-in-a-row anywhere on the board.
    function winExists(player) {
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (board[r][c] === player) {
            const directions = [
              { dr: 0, dc: 1 },
              { dr: 1, dc: 0 },
              { dr: 1, dc: 1 },
              { dr: 1, dc: -1 }
            ];
            for (const { dr, dc } of directions) {
              let count = 1;
              let nr = r + dr, nc = c + dc;
              while (isValid(nr, nc) && board[nr][nc] === player) {
                count++;
                nr += dr;
                nc += dc;
              }
              if (count >= 5) return true;
            }
          }
        }
      }
      return false;
    }
    function checkWin(row, col, player) {
      const directions = [
        { dr: 0, dc: 1 },
        { dr: 1, dc: 0 },
        { dr: 1, dc: 1 },
        { dr: 1, dc: -1 }
      ];
      for (let { dr, dc } of directions) {
        const line = getLine(row, col, dr, dc, player);
        if (line.length >= 5) {
          return line;
        }
      }
      return null;
    }
    function getLine(row, col, dr, dc, player) {
      let line = [[row, col]];
      let r = row + dr, c = col + dc;
      while (isValid(r, c) && board[r][c] === player) {
        line.push([r, c]);
        r += dr;
        c += dc;
      }
      r = row - dr, c = col - dc;
      while (isValid(r, c) && board[r][c] === player) {
        line.unshift([r, c]);
        r -= dr;
        c -= dc;
      }
      return line;
    }
    function isValid(row, col) {
      return row >= 0 && row < boardSize && col >= 0 && col < boardSize;
    }

    /********** HIGHLIGHT WINNING STONES **********/
    function highlightWinningStones(positions) {
      positions.forEach(([row, col]) => {
        const key = `${row}-${col}`;
        if (stoneElements[key]) {
          stoneElements[key].classList.add("winning-stone");
        }
      });
    }

    /********** CELEBRATION EFFECTS **********/
    function triggerCelebrationEffect() {
      confetti({
        particleCount: 100,
        spread: 70,
        origin: { x: 0, y: 0.5 }
      });
      confetti({
        particleCount: 100,
        spread: 70,
        origin: { x: 1, y: 0.5 }
      });
      createRibbons();
    }
    function createRibbons() {
      for (let i = 0; i < 20; i++) {
        const ribbon = document.createElement("div");
        ribbon.classList.add("ribbon");
        if (Math.random() < 0.5) {
          ribbon.style.left = (Math.random() * 30) + "%";
        } else {
          ribbon.style.right = (Math.random() * 30) + "%";
        }
        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
        const color = colors[Math.floor(Math.random() * colors.length)];
        ribbon.style.background = `linear-gradient(to bottom, ${color}, white)`;
        ribbon.style.animationDelay = (Math.random() * 0.5) + 's';
        document.body.appendChild(ribbon);
        setTimeout(() => {
          ribbon.remove();
        }, 2500);
      }
    }

    /********** IMPROVED AI LOGIC **********/
    function aiMakeMove() {
      if (gameOver) return;
      
      const startTime = Date.now();
      let bestMove = null;
      let bestValue = -Infinity;
      
      const moves = getCandidateMoves();
      if (moves.length === 0) return;

      // Iterative deepening with time management
      for (let depth = 1; depth <= AI_SEARCH_DEPTH; depth++) {
        if (Date.now() - startTime > 1000) break; // Safety timeout
        
        for (const move of moves) {
          board[move.row][move.col] = "white";
          const value = minimax(depth, false, -Infinity, Infinity);
          board[move.row][move.col] = "";
          
          if (value > bestValue) {
            bestValue = value;
            bestMove = move;
          }
        }
      }

      if (bestMove) makeAIMove(bestMove);
    }

    function makeAIMove(move) {
      board[move.row][move.col] = "white";
      
      const winPositions = checkWin(move.row, move.col, "white");
      if (winPositions) {
        endGame("White wins!", winPositions);
        return;
      }
      
      if (isBoardFull()) {
        endGame("Draw!");
        return;
      }
      
      currentPlayer = "black";
      messageEl.textContent = "Current Turn: Black";
    }

    /********** OPTIMIZED CANDIDATE MOVES **********/
    function getCandidateMoves() {
      const moves = new Set();
      const existingStones = [];
      
      // Collect all existing stones
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (board[r][c] !== "") existingStones.push([r, c]);
        }
      }

      // Generate moves around existing stones (2 spaces)
      existingStones.forEach(([r, c]) => {
        for (let dr = -2; dr <= 2; dr++) {
          for (let dc = -2; dc <= 2; dc++) {
            const nr = r + dr, nc = c + dc;
            if (isValid(nr, nc) && board[nr][nc] === "") {
              moves.add(`${nr}-${nc}`);
            }
          }
        }
      });

      // Fallback to center if no moves
      if (moves.size === 0) {
        const center = Math.floor(boardSize/2);
        return [{ row: center, col: center }];
      }

      // Convert to sorted array (by potential)
      return Array.from(moves).map(s => {
        const [r, c] = s.split('-').map(Number);
        return { row: r, col: c, score: quickEvaluate(r, c) };
      }).sort((a, b) => b.score - a.score).slice(0, 15); // Limit to top 15 moves
    }

    /********** OPTIMIZED EVALUATION **********/
    function quickEvaluate(r, c) {
      // Fast approximation for move ordering
      let score = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          if (isValid(r+dr, c+dc) && board[r+dr][c+dc] !== "") score += 10;
        }
      }
      return score;
    }

    function evaluateBoard() {
      if (winExists("white")) return PATTERN_WEIGHTS.five;
      if (winExists("black")) return -PATTERN_WEIGHTS.five;
      
      let whiteScore = 0, blackScore = 0;
      
      // Pattern detection for both players
      [["white", whiteScore], ["black", blackScore]].forEach(([player, score]) => {
        for (let r = 0; r < boardSize; r++) {
          for (let c = 0; c < boardSize; c++) {
            if (board[r][c] === player) {
              const directions = [[0,1], [1,0], [1,1], [1,-1]];
              
              directions.forEach(([dr, dc]) => {
                let sequence = 1;
                let openEnds = 0;
                let potential = 0;

                // Forward direction
                let [nr, nc] = [r+dr, c+dc];
                while (isValid(nr, nc) && (board[nr][nc] === player || board[nr][nc] === "")) {
                  if (board[nr][nc] === player) sequence++;
                  else if (isValid(nr+dr, nc+dc)) openEnds++;
                  nr += dr; nc += dc;
                }

                // Backward direction
                [nr, nc] = [r-dr, c-dc];
                while (isValid(nr, nc) && (board[nr][nc] === player || board[nr][nc] === "")) {
                  if (board[nr][nc] === player) sequence++;
                  else if (isValid(nr-dr, nc-dc)) openEnds++;
                  nr -= dr; nc -= dc;
                }

                // Evaluate patterns
                if (sequence >= 5) {
                  score += PATTERN_WEIGHTS.five;
                } else if (sequence === 4) {
                  score += openEnds >= 1 ? PATTERN_WEIGHTS.openFour : PATTERN_WEIGHTS.closedFour;
                } else if (sequence === 3) {
                  score += openEnds >= 1 ? PATTERN_WEIGHTS.openThree : PATTERN_WEIGHTS.closedThree;
                  if (openEnds >= 2) score += PATTERN_WEIGHTS.potentialFour;
                } else if (sequence === 2 && openEnds >= 1) {
                  score += PATTERN_WEIGHTS.openTwo;
                }
              });
            }
          }
        }
      });

      return whiteScore - blackScore;
    }

    /********** OPTIMIZED MINIMAX **********/
    function minimax(depth, maximizing, alpha, beta) {
      if (depth === 0 || gameOver) return evaluateBoard();
      
      const moves = getCandidateMoves();
      if (maximizing) {
        let maxEval = -Infinity;
        for (const move of moves) {
          board[move.row][move.col] = "white";
          const eval = minimax(depth-1, false, alpha, beta);
          board[move.row][move.col] = "";
          maxEval = Math.max(maxEval, eval);
          alpha = Math.max(alpha, eval);
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (const move of moves) {
          board[move.row][move.col] = "black";
          const eval = minimax(depth-1, true, alpha, beta);
          board[move.row][move.col] = "";
          minEval = Math.min(minEval, eval);
          beta = Math.min(beta, eval);
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }

    /********** CHECK IF BOARD IS FULL **********/
    function isBoardFull() {
      for (let i = 0; i < boardSize; i++) {
        for (let j = 0; j < boardSize; j++) {
          if (board[i][j] === "") return false;
        }
      }
      return true;
    }

    /********** UTILITY: Capitalize String **********/
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    /********** RESTART GAME **********/
    restartBtn.addEventListener("click", initBoard);

    // Initialize the game when the page loads.
    initBoard();
  </script>
</body>
</html>